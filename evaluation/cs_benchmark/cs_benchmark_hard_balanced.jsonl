{"doc_id": "hardb_001", "domain_topic": "algorithms.sorting", "source_text": "Merge sort divides the array, sorts each half, and merges them. This guarantees O(n log n) time in all cases.", "generated_claim": "Merge sort always runs in O(n log n) time", "gold_label": "VERIFIED", "evidence_span": "This guarantees O(n log n) time in all cases.", "difficulty": "hard", "source_type": "textbook", "claim_type": "performance", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Explicit complexity statement"}}
{"doc_id": "hardb_002", "domain_topic": "datastructures.btree", "source_text": "B-trees are height-balanced search trees. Because they are balanced, search takes O(log n) time.", "generated_claim": "B-trees have O(log n) search time due to balance", "gold_label": "VERIFIED", "evidence_span": "Because they are balanced, search takes O(log n) time.", "difficulty": "hard", "source_type": "textbook", "claim_type": "performance", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Direct support"}}
{"doc_id": "hardb_003", "domain_topic": "security.cryptography", "source_text": "RSA security relies on the hardness of factoring large semiprimes. RSA is currently secure against known classical attacks based on factoring.", "generated_claim": "RSA is secure against known classical factoring attacks", "gold_label": "VERIFIED", "evidence_span": "RSA is currently secure against known classical attacks based on factoring.", "difficulty": "hard", "source_type": "paper", "claim_type": "definition", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Direct statement"}}
{"doc_id": "hardb_004", "domain_topic": "compilers.parsing", "source_text": "LR parsers can handle left recursion and are more powerful than LL parsers. LR parsers can parse any context-free language, while LL parsers cannot.", "generated_claim": "LR parsers can parse any context-free language while LL parsers cannot", "gold_label": "VERIFIED", "evidence_span": "LR parsers can parse any context-free language, while LL parsers cannot.", "difficulty": "hard", "source_type": "textbook", "claim_type": "definition", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Explicit comparison"}}
{"doc_id": "hardb_005", "domain_topic": "networking.congestion_control", "source_text": "TCP slow start begins with a small congestion window and increases it rapidly. Slow Start begins with a small congestion window, which is why it is called slow start.", "generated_claim": "Slow Start is called slow because it begins with a small congestion window", "gold_label": "VERIFIED", "evidence_span": "Slow Start begins with a small congestion window, which is why it is called slow start.", "difficulty": "medium", "source_type": "paper", "claim_type": "definition", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Explicit naming rationale"}}
{"doc_id": "hardb_006", "domain_topic": "datastructures.heap", "source_text": "A min-heap guarantees that the root is the minimum element. The root is always the smallest element in a min-heap.", "generated_claim": "The root of a min-heap is the smallest element", "gold_label": "VERIFIED", "evidence_span": "The root is always the smallest element in a min-heap.", "difficulty": "medium", "source_type": "textbook", "claim_type": "definition", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Direct property"}}
{"doc_id": "hardb_007", "domain_topic": "algorithms.searching", "source_text": "Binary search requires a sorted array. Each comparison removes half of the remaining elements, yielding O(log n) time.", "generated_claim": "Binary search runs in O(log n) time on sorted arrays", "gold_label": "VERIFIED", "evidence_span": "Each comparison removes half of the remaining elements, yielding O(log n) time.", "difficulty": "hard", "source_type": "textbook", "claim_type": "performance", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Explicit complexity"}}
{"doc_id": "hardb_008", "domain_topic": "databases.transactions", "source_text": "ACID stands for atomicity, consistency, isolation, and durability. Atomicity ensures that all operations in a transaction succeed or none do.", "generated_claim": "Atomicity means all operations in a transaction succeed or none do", "gold_label": "VERIFIED", "evidence_span": "Atomicity ensures that all operations in a transaction succeed or none do.", "difficulty": "medium", "source_type": "textbook", "claim_type": "definition", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Direct definition"}}
{"doc_id": "hardb_009", "domain_topic": "algorithms.sorting", "source_text": "Quicksort has O(n log n) average-case complexity but O(n^2) worst-case complexity when pivots are poorly chosen.", "generated_claim": "Quicksort always has O(n log n) complexity", "gold_label": "REJECTED", "evidence_span": "", "difficulty": "hard", "source_type": "textbook", "claim_type": "performance", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Contradicts worst-case"}}
{"doc_id": "hardb_010", "domain_topic": "algorithms.searching", "source_text": "Binary search requires a sorted array. If the array is unsorted, results are unreliable.", "generated_claim": "Binary search works correctly on unsorted arrays", "gold_label": "REJECTED", "evidence_span": "", "difficulty": "hard", "source_type": "paper", "claim_type": "performance", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Unsuitable input"}}
{"doc_id": "hardb_011", "domain_topic": "datastructures.graph", "source_text": "Adjacency matrices use O(V^2) space. Adjacency lists use O(V+E) space.", "generated_claim": "Adjacency matrices always use less space than lists", "gold_label": "REJECTED", "evidence_span": "", "difficulty": "hard", "source_type": "textbook", "claim_type": "performance", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Space claim is false"}}
{"doc_id": "hardb_012", "domain_topic": "complexity.nphard", "source_text": "NP-complete problems are in NP and NP-hard. Whether they have polynomial-time solutions is unknown.", "generated_claim": "All NP-complete problems have known polynomial-time solutions", "gold_label": "REJECTED", "evidence_span": "", "difficulty": "hard", "source_type": "paper", "claim_type": "performance", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Open problem"}}
{"doc_id": "hardb_013", "domain_topic": "security.authentication", "source_text": "Salting prevents rainbow table attacks but does not increase brute-force cost per attempt.", "generated_claim": "Salting makes brute-force attacks computationally harder", "gold_label": "REJECTED", "evidence_span": "", "difficulty": "hard", "source_type": "textbook", "claim_type": "security", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Brute-force cost unchanged"}}
{"doc_id": "hardb_014", "domain_topic": "databases.indexes", "source_text": "Indexes can speed up reads but can slow down writes due to maintenance overhead.", "generated_claim": "Indexes always improve performance", "gold_label": "REJECTED", "evidence_span": "", "difficulty": "hard", "source_type": "textbook", "claim_type": "performance", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Tradeoff exists"}}
{"doc_id": "hardb_015", "domain_topic": "machinelearning.generalization", "source_text": "Larger models can generalize well with proper regularization. Overfitting is not guaranteed by size alone.", "generated_claim": "Larger models always overfit more than smaller models", "gold_label": "REJECTED", "evidence_span": "", "difficulty": "hard", "source_type": "paper", "claim_type": "performance", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Size alone is not decisive"}}
{"doc_id": "hardb_016", "domain_topic": "algorithms.approximation", "source_text": "Some NP-hard problems have constant-factor approximations, while others do not unless P=NP.", "generated_claim": "All NP-hard problems have constant-factor approximation algorithms", "gold_label": "REJECTED", "evidence_span": "", "difficulty": "hard", "source_type": "paper", "claim_type": "performance", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Approximability varies"}}
{"doc_id": "hardb_017", "domain_topic": "algorithms.dynamic_programming", "source_text": "Dynamic programming applies when optimal substructure and overlapping subproblems are present.", "generated_claim": "Any problem with overlapping subproblems can be solved optimally with dynamic programming", "gold_label": "LOW_CONFIDENCE", "evidence_span": "Dynamic programming applies when optimal substructure and overlapping subproblems are present.", "difficulty": "hard", "source_type": "textbook", "claim_type": "performance", "reasoning_type": "implicit", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Missing optimal substructure"}}
{"doc_id": "hardb_018", "domain_topic": "datastructures.trie", "source_text": "Tries share prefixes and can reduce space for similar strings, but may use more space for unrelated short keys.", "generated_claim": "Tries use more space than hash tables", "gold_label": "LOW_CONFIDENCE", "evidence_span": "Tries share prefixes and can reduce space for similar strings", "difficulty": "hard", "source_type": "textbook", "claim_type": "performance", "reasoning_type": "implicit", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Context dependent"}}
{"doc_id": "hardb_019", "domain_topic": "networking.protocols", "source_text": "TCP retransmits lost packets and uses sequence numbers to discard duplicates at the receiver.", "generated_claim": "TCP can deliver duplicate packets to the application layer", "gold_label": "LOW_CONFIDENCE", "evidence_span": "TCP retransmits lost packets and uses sequence numbers to discard duplicates", "difficulty": "hard", "source_type": "textbook", "claim_type": "performance", "reasoning_type": "implicit", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Depends on stack behavior"}}
{"doc_id": "hardb_020", "domain_topic": "algorithms.hashing", "source_text": "Load factor affects collision probability. Higher load factors increase collisions.", "generated_claim": "Perfect hashing eliminates collisions regardless of load factor", "gold_label": "LOW_CONFIDENCE", "evidence_span": "Load factor affects collision probability", "difficulty": "hard", "source_type": "textbook", "claim_type": "definition", "reasoning_type": "implicit", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Needs stronger refutation"}}
