{"doc_id": "dom_algo_001", "domain_topic": "algorithms.sorting", "source_text": "Quicksort has O(n log n) average case but O(n^2) worst case complexity. Merge sort has consistent O(n log n) complexity.", "generated_claim": "Merge sort is always faster than quicksort", "gold_label": "REJECTED", "evidence_span": "", "difficulty": "medium", "source_type": "textbook", "claim_type": "performance", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Domain: algorithms"}}
{"doc_id": "dom_algo_002", "domain_topic": "algorithms.searching", "source_text": "Linear search checks elements sequentially in O(n) time. Binary search requires sorting first but searches in O(log n) time.", "generated_claim": "Binary search is optimal for all unsorted lists", "gold_label": "REJECTED", "evidence_span": "", "difficulty": "medium", "source_type": "textbook", "claim_type": "performance", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Domain: algorithms"}}
{"doc_id": "dom_algo_003", "domain_topic": "algorithms.dynamic_programming", "source_text": "Dynamic programming requires optimal substructure and overlapping subproblems. It trades memory for speed through memoization.", "generated_claim": "Dynamic programming solves all optimization problems", "gold_label": "REJECTED", "evidence_span": "", "difficulty": "hard", "source_type": "textbook", "claim_type": "performance", "reasoning_type": "implicit", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Domain: algorithms"}}
{"doc_id": "dom_ds_001", "domain_topic": "datastructures.hashtable", "source_text": "Hash tables use hash functions to map keys to indices. Collisions are handled through chaining or open addressing.", "generated_claim": "Hash tables never have collisions with perfect hash functions", "gold_label": "REJECTED", "evidence_span": "", "difficulty": "medium", "source_type": "textbook", "claim_type": "performance", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Domain: datastructures"}}
{"doc_id": "dom_ds_002", "domain_topic": "datastructures.binarytree", "source_text": "A binary search tree maintains order: left subtree < parent < right subtree. This enables O(log n) average search.", "generated_claim": "All binary search trees have balanced height", "gold_label": "REJECTED", "evidence_span": "", "difficulty": "medium", "source_type": "textbook", "claim_type": "performance", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Domain: datastructures"}}
{"doc_id": "dom_ds_003", "domain_topic": "datastructures.graph", "source_text": "Graphs can be represented as adjacency matrices or adjacency lists. Adjacency matrices use O(V^2) space, lists use O(V+E) space.", "generated_claim": "Adjacency lists are always better than matrices", "gold_label": "REJECTED", "evidence_span": "", "difficulty": "medium", "source_type": "textbook", "claim_type": "performance", "reasoning_type": "implicit", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Domain: datastructures"}}
{"doc_id": "dom_cplx_001", "domain_topic": "complexity.nphard", "source_text": "NP-hard problems are at least as hard as the hardest problems in NP. NP-complete problems are NP-hard and in NP.", "generated_claim": "All NP-hard problems are NP-complete", "gold_label": "REJECTED", "evidence_span": "", "difficulty": "hard", "source_type": "paper", "claim_type": "definition", "reasoning_type": "implicit", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Domain: complexity"}}
{"doc_id": "dom_cplx_002", "domain_topic": "complexity.correlation", "source_text": "Pearson correlation measures linear relationship between variables. Values range from -1 to 1.", "generated_claim": "Correlation proves causation", "gold_label": "REJECTED", "evidence_span": "", "difficulty": "medium", "source_type": "textbook", "claim_type": "definition", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Domain: complexity"}}
{"doc_id": "dom_net_001", "domain_topic": "networking.protocols", "source_text": "TCP ensures reliable delivery. UDP does not guarantee delivery but has lower latency.", "generated_claim": "UDP is always faster than TCP", "gold_label": "REJECTED", "evidence_span": "", "difficulty": "medium", "source_type": "textbook", "claim_type": "performance", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Domain: networking"}}
{"doc_id": "dom_net_002", "domain_topic": "networking.congestion", "source_text": "TCP congestion control uses window-based flow control. Receivers communicate available buffer space via window size.", "generated_claim": "TCP window size is fixed at initialization", "gold_label": "REJECTED", "evidence_span": "", "difficulty": "medium", "source_type": "textbook", "claim_type": "performance", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Domain: networking"}}
{"doc_id": "dom_sec_001", "domain_topic": "security.encryption", "source_text": "Symmetric encryption uses one key for both encryption and decryption. Asymmetric uses public-private key pairs.", "generated_claim": "Symmetric encryption is always more secure than asymmetric", "gold_label": "REJECTED", "evidence_span": "", "difficulty": "medium", "source_type": "textbook", "claim_type": "security", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Domain: security"}}
{"doc_id": "dom_sec_002", "domain_topic": "security.authentication", "source_text": "Passwords should be hashed with unique salts. Salting prevents rainbow table attacks but not brute force.", "generated_claim": "Salted passwords prevent all attacks", "gold_label": "REJECTED", "evidence_span": "", "difficulty": "medium", "source_type": "textbook", "claim_type": "security", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Domain: security"}}
{"doc_id": "dom_db_001", "domain_topic": "databases.indexes", "source_text": "Database indexes speed up queries but slow down inserts and deletes. B-tree indexes are most common.", "generated_claim": "Database indexes always improve performance", "gold_label": "REJECTED", "evidence_span": "", "difficulty": "medium", "source_type": "textbook", "claim_type": "performance", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Domain: databases"}}
{"doc_id": "dom_db_002", "domain_topic": "databases.queries", "source_text": "Query optimization attempts to find most efficient execution plan. Cardinality estimation affects plan quality.", "generated_claim": "SQL optimizers always find optimal query plans", "gold_label": "REJECTED", "evidence_span": "", "difficulty": "medium", "source_type": "textbook", "claim_type": "performance", "reasoning_type": "implicit", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Domain: databases"}}
{"doc_id": "dom_ml_001", "domain_topic": "machinelearning.classification", "source_text": "Classification models predict discrete categories. Training on imbalanced data can bias predictions toward majority class.", "generated_claim": "Balanced datasets are unnecessary for classification", "gold_label": "REJECTED", "evidence_span": "", "difficulty": "medium", "source_type": "paper", "claim_type": "performance", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Domain: machinelearning"}}
{"doc_id": "dom_ml_002", "domain_topic": "machinelearning.regularization", "source_text": "L1 regularization produces sparse models by driving some weights to zero. L2 regularization spreads weights but rarely to zero.", "generated_claim": "L1 and L2 regularization produce identical results", "gold_label": "REJECTED", "evidence_span": "", "difficulty": "medium", "source_type": "paper", "claim_type": "performance", "reasoning_type": "implicit", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Domain: machinelearning"}}
{"doc_id": "dom_com_001", "domain_topic": "compilers.optimization", "source_text": "Compiler optimizations improve code efficiency through techniques like dead code elimination and constant folding.", "generated_claim": "Compiler optimizations never increase binary size", "gold_label": "REJECTED", "evidence_span": "", "difficulty": "medium", "source_type": "textbook", "claim_type": "performance", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Domain: compilers"}}
{"doc_id": "dom_com_002", "domain_topic": "compilers.parsing", "source_text": "LL parsers are top-down and cannot handle left recursion. LR parsers are bottom-up and can handle left recursion.", "generated_claim": "All context-free grammars can be parsed by LL parsers", "gold_label": "REJECTED", "evidence_span": "", "difficulty": "hard", "source_type": "textbook", "claim_type": "definition", "reasoning_type": "implicit", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Domain: compilers"}}
{"doc_id": "dom_algo_004", "domain_topic": "algorithms.sorting", "source_text": "Heapsort uses a heap data structure to sort elements. It guarantees O(n log n) time complexity in all cases.", "generated_claim": "Heapsort always performs in-place sorting", "gold_label": "VERIFIED", "evidence_span": "Heapsort uses a heap data structure", "difficulty": "medium", "source_type": "textbook", "claim_type": "performance", "reasoning_type": "implicit", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Domain: algorithms"}}
{"doc_id": "dom_ds_004", "domain_topic": "datastructures.linkedlist", "source_text": "Linked lists allow efficient insertion and deletion at known positions through pointer updates. Access requires traversal.", "generated_claim": "Linked lists have O(1) insertion at any position", "gold_label": "REJECTED", "evidence_span": "", "difficulty": "medium", "source_type": "textbook", "claim_type": "performance", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Domain: datastructures"}}
{"doc_id": "dom_cplx_003", "domain_topic": "complexity.ptime", "source_text": "P-time problems are solvable in polynomial time. Examples include sorting and searching.", "generated_claim": "All practical problems are in P-time", "gold_label": "REJECTED", "evidence_span": "", "difficulty": "hard", "source_type": "paper", "claim_type": "performance", "reasoning_type": "implicit", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Domain: complexity"}}
{"doc_id": "dom_net_003", "domain_topic": "networking.routing", "source_text": "Routing protocols find paths between network nodes. BGP selects paths based on policy, not necessarily shortest.", "generated_claim": "Internet routing always uses optimally shortest paths", "gold_label": "REJECTED", "evidence_span": "", "difficulty": "medium", "source_type": "textbook", "claim_type": "performance", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Domain: networking"}}
