{"doc_id": "adv_001", "domain_topic": "algorithms.sorting", "source_text": "The time complexity of quicksort is O(n log n) on average but O(n^2) in the worst case scenario.", "generated_claim": "Quicksort's average performance is different from its worst case", "gold_label": "VERIFIED", "evidence_span": "O(n log n) on average but O(n^2) in the worst case", "difficulty": "medium", "source_type": "textbook", "claim_type": "performance", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Paraphrased"}}
{"doc_id": "adv_002", "domain_topic": "datastructures.binarytree", "source_text": "A BST maintains the invariant that items in the left subtree are smaller than items in the right subtree relative to the root node. This structure allows for efficient search with O(log n) average lookup time when the tree is balanced.", "generated_claim": "Binary search trees support efficient search when properly structured", "gold_label": "VERIFIED", "evidence_span": "allows for efficient search with O(log n) average lookup time", "difficulty": "medium", "source_type": "textbook", "claim_type": "performance", "reasoning_type": "implicit", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Subtle paraphrase with proper structure phrasing"}}
{"doc_id": "adv_003", "domain_topic": "algorithms.searching", "source_text": "Binary search cannot be applied to unsorted data because the algorithm assumes the list is pre-sorted.", "generated_claim": "Unsorted arrays prevent binary search from working correctly", "gold_label": "VERIFIED", "evidence_span": "Binary search cannot be applied to unsorted data", "difficulty": "medium", "source_type": "textbook", "claim_type": "performance", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Rephrased with different subject focus"}}
{"doc_id": "adv_004", "domain_topic": "datastructures.hashtable", "source_text": "Hash tables with good hash functions distribute items uniformly across buckets. When many items map to the same bucket (high load factor), average lookup degrades from O(1) to O(n).", "generated_claim": "High load in hash tables degrades search performance", "gold_label": "VERIFIED", "evidence_span": "high load factor, average lookup degrades from O(1) to O(n)", "difficulty": "medium", "source_type": "textbook", "claim_type": "performance", "reasoning_type": "implicit", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Compressed statement"}}
{"doc_id": "adv_005", "domain_topic": "datastructures.linkedlist", "source_text": "To retrieve an item at position k in a linked list, you must follow k pointers starting from the head node.", "generated_claim": "Finding elements in linked lists requires traversal", "gold_label": "VERIFIED", "evidence_span": "you must follow k pointers", "difficulty": "easy", "source_type": "textbook", "claim_type": "performance", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Abstracted paraphrase"}}
{"doc_id": "adv_006", "domain_topic": "complexity.big_o", "source_text": "When analyzing algorithms, Big O describes an upper bound on growth, not the exact growth rate.", "generated_claim": "Big O represents the worst-case scenario bound", "gold_label": "VERIFIED", "evidence_span": "Big O describes an upper bound", "difficulty": "easy", "source_type": "textbook", "claim_type": "definition", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Clarified paraphrase"}}
{"doc_id": "adv_007", "domain_topic": "algorithms.recursion", "source_text": "Recursive algorithms must include a termination condition that prevents infinite recursion.", "generated_claim": "Without base cases, recursive functions cannot halt", "gold_label": "VERIFIED", "evidence_span": "must include a termination condition", "difficulty": "easy", "source_type": "textbook", "claim_type": "definition", "reasoning_type": "implicit", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Inverted perspective"}}
{"doc_id": "adv_008", "domain_topic": "datastructures.stack", "source_text": "The stack data structure removes items in LIFO order, so the most recently added item is removed first.", "generated_claim": "New items in stacks come out before older items", "gold_label": "VERIFIED", "evidence_span": "most recently added item is removed first", "difficulty": "easy", "source_type": "textbook", "claim_type": "definition", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Colloquial phrasing"}}
{"doc_id": "adv_009", "domain_topic": "algorithms.merge_sort", "source_text": "Merge sort consistently performs in O(n log n) time regardless of input order or pattern.", "generated_claim": "Merge sort has the same complexity for all inputs", "gold_label": "VERIFIED", "evidence_span": "consistently performs in O(n log n) time regardless", "difficulty": "medium", "source_type": "textbook", "claim_type": "performance", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Generalized statement"}}
{"doc_id": "adv_010", "domain_topic": "datastructures.queue", "source_text": "Queues implement FIFO ordering where items exit in the same order they enter.", "generated_claim": "Queue order matches insertion sequence", "gold_label": "VERIFIED", "evidence_span": "FIFO ordering", "difficulty": "easy", "source_type": "textbook", "claim_type": "definition", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Simplified paraphrase"}}
{"doc_id": "adv_011", "domain_topic": "algorithms.sorting", "source_text": "Insertion sort in the worst-case scenario when the array is reverse-sorted requires O(n^2) comparisons.", "generated_claim": "Insertion sort performs poorly on reverse-sorted data", "gold_label": "VERIFIED", "evidence_span": "worst-case scenario when the array is reverse-sorted requires O(n^2)", "difficulty": "medium", "source_type": "textbook", "claim_type": "performance", "reasoning_type": "implicit", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Informal language"}}
{"doc_id": "adv_012", "domain_topic": "complexity.space_complexity", "source_text": "The amount of memory an algorithm consumes as a function of its input size is called space complexity.", "generated_claim": "Memory usage patterns define space complexity", "gold_label": "VERIFIED", "evidence_span": "amount of memory an algorithm consumes", "difficulty": "easy", "source_type": "textbook", "claim_type": "definition", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Casual rephrasing"}}
{"doc_id": "adv_013", "domain_topic": "algorithms.linear_search", "source_text": "In the worst case, linear search must examine all items in the list to determine if an item is not present.", "generated_claim": "Not finding an element requires checking everything", "gold_label": "VERIFIED", "evidence_span": "must examine all items in the list to determine if an item is not present", "difficulty": "medium", "source_type": "textbook", "claim_type": "performance", "reasoning_type": "implicit", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Colloquial"}}
{"doc_id": "adv_014", "domain_topic": "datastructures.array", "source_text": "Arrays allow constant-time random access to elements through direct index computation, giving O(1) lookup.", "generated_claim": "Array indexing provides constant nanosecond lookups", "gold_label": "VERIFIED", "evidence_span": "constant-time random access", "difficulty": "medium", "source_type": "textbook", "claim_type": "performance", "reasoning_type": "implicit", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Added specificity"}}
{"doc_id": "adv_015", "domain_topic": "algorithms.binary_search", "source_text": "Binary search's correctness depends critically on the input array being sorted in ascending order.", "generated_claim": "Ordering requirements are essential for binary search", "gold_label": "VERIFIED", "evidence_span": "input array being sorted in ascending order", "difficulty": "medium", "source_type": "textbook", "claim_type": "performance", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Abstracted"}}
{"doc_id": "adv_016", "domain_topic": "complexity.time", "source_text": "Time complexity measures how execution duration scales with increasing input size. Algorithms with smaller Big O are more scalable.", "generated_claim": "Scalability correlates with Big O complexity class", "gold_label": "VERIFIED", "evidence_span": "Big O", "difficulty": "medium", "source_type": "textbook", "claim_type": "definition", "reasoning_type": "implicit", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Generalized"}}
{"doc_id": "adv_017", "domain_topic": "algorithms.graph_traversal", "source_text": "Depth-first search explores graph branches exhaustively using a stack-based data structure for tracking.", "generated_claim": "DFS exhausts branches before backtracking", "gold_label": "VERIFIED", "evidence_span": "explores graph branches exhaustively", "difficulty": "medium", "source_type": "textbook", "claim_type": "definition", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Simplified"}}
{"doc_id": "adv_018", "domain_topic": "datastructures.heap", "source_text": "A min-heap is a complete binary tree satisfying the min-heap property where each parent is smaller than its children.", "generated_claim": "Parent nodes in min-heaps are smallest in their subtrees", "gold_label": "REJECTED", "evidence_span": "", "difficulty": "medium", "source_type": "textbook", "claim_type": "definition", "reasoning_type": "implicit", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Overstated locally vs globally"}}
{"doc_id": "adv_019", "domain_topic": "algorithms.sorting", "source_text": "Bubble sort repeatedly traverses the list, comparing adjacent elements and swapping incorrectly ordered pairs until sorted.", "generated_claim": "Bubble sort reorders elements progressively per pass", "gold_label": "VERIFIED", "evidence_span": "repeatedly traverses the list, comparing adjacent elements and swapping", "difficulty": "easy", "source_type": "textbook", "claim_type": "definition", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "High-level description"}}
{"doc_id": "adv_020", "domain_topic": "complexity.correlation", "source_text": "Statistically, correlation between variables does not establish that one variable causes changes in the other.", "generated_claim": "Relationship strength alone cannot prove causation", "gold_label": "VERIFIED", "evidence_span": "correlation between variables does not establish that one variable causes", "difficulty": "medium", "source_type": "textbook", "claim_type": "definition", "reasoning_type": "direct", "metadata": {"creation_date": "2026-02-17", "verifier": "research", "notes": "Abstracted statistical concept"}}
